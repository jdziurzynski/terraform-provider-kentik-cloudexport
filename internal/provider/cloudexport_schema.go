package provider

import (
	"fmt"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/kentik/community_sdk_golang/kentikapi/cloudexport"
)

// CloudExportSchema reflects V202101beta1CloudExport type and defines a CloudExport item used in terraform .tf files
// Note: currently, nesting an object is only possible by using single-item List element (Terraform limitation)
//nolint: gocognit, gocyclo
func makeCloudExportSchema(mode schemaMode) map[string]*schema.Schema {
	return map[string]*schema.Schema{
		"id": {
			Type:        schema.TypeString,
			Computed:    mode == create || mode == readList, // provided by server on creating/listing items
			Required:    mode == readSingle,                 // provided by user in order to read single item
			Description: "The internal cloud export identifier. This is Read-only and assigned by Kentik",
		},
		"type": {
			Type:     schema.TypeString,
			Computed: mode == readSingle || mode == readList, // provided by server on read
			Required: mode == create,                         // provided by user on create
			Description: "CLOUD_EXPORT_TYPE_UNSPECIFIED: Invalid or incomplete exports. " +
				"CLOUD_EXPORT_TYPE_KENTIK_MANAGED: Cloud exports that are managed by Kentik. " +
				"CLOUD_EXPORT_TYPE_CUSTOMER_MANAGED: Exports that are managed by Kentik customers " +
				"(eg. by running an agent)",
		},
		"enabled": {
			Type:        schema.TypeBool,
			Computed:    mode == readSingle || mode == readList, // provided by server on read
			Required:    mode == create,                         // provided by user on create
			Description: "Whether this task is enabled and intended to run, or disabled",
		},
		"name": {
			Type:        schema.TypeString,
			Computed:    mode == readSingle || mode == readList, // provided by server on read
			Required:    mode == create,                         // provided by user on create
			Description: "A short name for this export",
		},
		"description": {
			Type:        schema.TypeString,
			Computed:    mode == readSingle || mode == readList, // provided by server on read
			Optional:    mode == create,                         // optionally provided by user on create
			Description: "An optional, longer description",
		},
		"api_root": {
			Type: schema.TypeString,
			// if not specified by user, API server will provide value for this attribute
			Computed: mode == readSingle || mode == readList || mode == create,
			Optional: mode == create, // optionally provided by user on create
			Description: "Hostname of the Kentik deployment where the API calls related to this export should go, " +
				"eg. api.kentik.com",
		},
		"flow_dest": {
			Type: schema.TypeString,
			// if not specified by user, API server will provide value for this attribute
			Computed: mode == readSingle || mode == readList || mode == create,
			Optional: mode == create, // optionally provided by user on create
			Description: "Hostname of the Kentik deployment where the data generated by this export should go, " +
				"eg. flow.kentik.com",
		},
		"plan_id": {
			Type:        schema.TypeString,
			Computed:    mode == readSingle || mode == readList, // provided by server on read
			Required:    mode == create,                         // provided by user on create
			Description: "The identifier of the Kentik plan associated with this task",
		},
		"cloud_provider": {
			Type:        schema.TypeString,
			Computed:    mode == readSingle || mode == readList, // provided by server on read
			Required:    mode == create,                         // provided by user on create
			Description: "The cloud provider targeted by this export (aws, azure, gce, ibm)",
		},
		"aws":            makeAWSSchema(mode),
		"azure":          makeAzureSchema(mode),
		"bgp":            makeBGPSchema(mode),
		"gce":            makeGCESchema(mode),
		"ibm":            makeIBMSchema(mode),
		"current_status": makeCurrentStatusSchema(),
	}
}

func makeAWSSchema(mode schemaMode) *schema.Schema {
	return &schema.Schema{
		// nested object
		Type:        schema.TypeList,
		Computed:    mode == readSingle || mode == readList, // provided by server on read
		Optional:    mode == create,                         // optionally provided by user on create
		Description: "Properties specific to Amazon Web Services \"vpc flow logs\" exports",
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"bucket": {
					Type:        schema.TypeString,
					Computed:    mode == readSingle || mode == readList, // provided by server on read
					Required:    mode == create,                         // provided by user on create
					Description: "Source S3 bucket to fetch vpc flow logs from",
				},
				"iam_role_arn": {
					Type:        schema.TypeString,
					Computed:    mode == readSingle || mode == readList, // provided by server on read
					Required:    mode == create,                         // provided by user on create
					Description: "ARN for the IAM role to assume when fetching data or making AWS calls for this export",
				},
				"region": {
					Type:        schema.TypeString,
					Computed:    mode == readSingle || mode == readList, // provided by server on read
					Required:    mode == create,                         // provided by user on create
					Description: "AWS region where this bucket resides",
				},
				"delete_after_read": {
					Type:        schema.TypeBool,
					Computed:    mode == readSingle || mode == readList, // provided by server on read
					Required:    mode == create,                         // provided by user on create
					Description: "If true, attempt to delete vpc flow log chunks from S3 after they've been read",
				},
				"multiple_buckets": {
					Type:     schema.TypeBool,
					Computed: mode == readSingle || mode == readList, // provided by server on read
					Required: mode == create,                         // provided by user on create
				},
			},
		},
	}
}

func makeAzureSchema(mode schemaMode) *schema.Schema {
	return &schema.Schema{
		// nested object
		Type:        schema.TypeList,
		Computed:    mode == readSingle || mode == readList, // provided by server on read
		Optional:    mode == create,                         // optionally provided by user on create
		Description: "Properties specific to Azure exports",
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"location": {
					Type:     schema.TypeString,
					Computed: mode == readSingle || mode == readList, // provided by server on read
					Required: mode == create,                         // provided by user on create
				},
				"resource_group": {
					Type:     schema.TypeString,
					Computed: mode == readSingle || mode == readList, // provided by server on read
					Required: mode == create,                         // provided by user on create
				},
				"storage_account": {
					Type:     schema.TypeString,
					Computed: mode == readSingle || mode == readList, // provided by server on read
					Required: mode == create,                         // provided by user on create
				},
				"subscription_id": {
					Type:     schema.TypeString,
					Computed: mode == readSingle || mode == readList, // provided by server on read
					Required: mode == create,                         // provided by user on create
				},
				"security_principal_enabled": {
					Type:     schema.TypeBool,
					Computed: mode == readSingle || mode == readList, // provided by server on read
					Required: mode == create,                         // provided by user on create
				},
			},
		},
	}
}

func makeBGPSchema(mode schemaMode) *schema.Schema {
	return &schema.Schema{
		// nested object
		Type:        schema.TypeList,
		Computed:    mode == readSingle || mode == readList, // provided by server on read
		Optional:    mode == create,                         // optionally provided by user on create
		Description: "Optional BGP related settings",
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"apply_bgp": {
					Type:        schema.TypeBool,
					Computed:    mode == readSingle || mode == readList, // provided by server on read
					Required:    mode == create,                         // provided by user on create
					Description: "If true, apply BGP data discovered via another device to the flow from this export",
				},
				"use_bgp_device_id": {
					Type:        schema.TypeString,
					Computed:    mode == readSingle || mode == readList, // provided by server on read
					Required:    mode == create,                         // provided by user on create
					Description: "Which other device to get BGP data from",
				},
				"device_bgp_type": {
					Type:        schema.TypeString,
					Computed:    mode == readSingle || mode == readList, // provided by server on read
					Required:    mode == create,                         // provided by user on create
					Description: "device, other_device, none",
				},
			},
		},
	}
}

func makeGCESchema(mode schemaMode) *schema.Schema {
	return &schema.Schema{
		// nested object
		Type:        schema.TypeList,
		Computed:    mode == readSingle || mode == readList, // provided by server on read
		Optional:    mode == create,                         // optionally provided by user on create
		Description: "Properties specific to Google Cloud export",
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"project": {
					Type:     schema.TypeString,
					Computed: mode == readSingle || mode == readList, // provided by server on read
					Required: mode == create,                         // provided by user on create
				},
				"subscription": {
					Type:     schema.TypeString,
					Computed: mode == readSingle || mode == readList, // provided by server on read
					Required: mode == create,                         // provided by user on create
				},
			},
		},
	}
}

func makeIBMSchema(mode schemaMode) *schema.Schema {
	return &schema.Schema{
		// nested object
		Type:        schema.TypeList,
		Computed:    mode == readSingle || mode == readList, // provided by server on read
		Optional:    mode == create,                         // optionally provided by user on create
		Description: "Properties specific to IBM Cloud exports",
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"bucket": {
					Type:     schema.TypeString,
					Computed: mode == readSingle || mode == readList, // provided by server on read
					Required: mode == create,                         // provided by user on create
				},
			},
		},
	}
}

func makeCurrentStatusSchema() *schema.Schema {
	return &schema.Schema{
		// nested object
		Type:        schema.TypeList,
		Computed:    true, // always provided by server
		Description: "Export task status",
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"status": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "OK, ERROR or other short and descriptive status",
				},
				"error_message": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "If not empty, the current error",
				},
				"flow_found": {
					Type:        schema.TypeBool,
					Computed:    true,
					Description: "If true, we found flow logs",
				},
				"api_access": {
					Type:     schema.TypeBool,
					Computed: true,
				},
				"storage_account_access": {
					Type:     schema.TypeBool,
					Computed: true,
				},
			},
		},
	}
}

// cloudExportToMap is used for API get operation to fill terraform resource from cloudexport item.
func cloudExportToMap(e *cloudexport.V202101beta1CloudExport) map[string]interface{} {
	o := make(map[string]interface{})
	if e == nil {
		return o
	}

	o["id"] = e.Id
	o["type"] = e.Type
	o["enabled"] = e.Enabled
	o["name"] = e.Name
	o["description"] = e.Description
	o["api_root"] = e.ApiRoot
	o["flow_dest"] = e.FlowDest
	o["plan_id"] = e.PlanId
	o["cloud_provider"] = e.CloudProvider

	if e.Aws != nil {
		aws := make(map[string]interface{})
		aws["bucket"] = e.Aws.Bucket
		aws["iam_role_arn"] = e.Aws.IamRoleArn
		aws["region"] = e.Aws.Region
		aws["delete_after_read"] = e.Aws.DeleteAfterRead
		aws["multiple_buckets"] = e.Aws.MultipleBuckets
		o["aws"] = []interface{}{aws}
	}

	if e.Azure != nil {
		azure := make(map[string]interface{})
		azure["location"] = e.Azure.Location
		azure["resource_group"] = e.Azure.ResourceGroup
		azure["storage_account"] = e.Azure.StorageAccount
		azure["subscription_id"] = e.Azure.SubscriptionId
		azure["security_principal_enabled"] = e.Azure.SecurityPrincipalEnabled
		o["azure"] = []interface{}{azure}
	}

	if e.Bgp != nil {
		bgp := make(map[string]interface{})
		bgp["apply_bgp"] = e.Bgp.ApplyBgp
		bgp["use_bgp_device_id"] = e.Bgp.UseBgpDeviceId
		bgp["device_bgp_type"] = e.Bgp.DeviceBgpType
		o["bgp"] = []interface{}{bgp}
	}

	if e.Gce != nil {
		gce := make(map[string]interface{})
		gce["project"] = e.Gce.Project
		gce["subscription"] = e.Gce.Subscription
		o["gce"] = []interface{}{gce}
	}

	if e.Ibm != nil {
		ibm := make(map[string]interface{})
		ibm["bucket"] = e.Ibm.Bucket
		o["ibm"] = []interface{}{ibm}
	}

	if e.CurrentStatus != nil {
		cs := make(map[string]interface{})
		cs["status"] = e.CurrentStatus.Status
		cs["error_message"] = e.CurrentStatus.ErrorMessage
		cs["flow_found"] = e.CurrentStatus.FlowFound
		cs["api_access"] = e.CurrentStatus.ApiAccess
		cs["storage_account_access"] = e.CurrentStatus.StorageAccountAccess
		o["current_status"] = []interface{}{cs}
	}

	return o
}

// resourceDataToCloudExport is used for API create/update operations to fill cloudexport item from terraform resource.
func resourceDataToCloudExport(d *schema.ResourceData) (*cloudexport.V202101beta1CloudExport, error) {
	// Note: only set the user-writable attributes, read-only attributes that are only generated on server side:
	// CurrentStatus, are left with nil values and so are not serialized and not sent to API server

	export := cloudexport.NewV202101beta1CloudExport()

	// required
	t := d.Get("type")
	export.SetType(cloudexport.V202101beta1CloudExportType(t.(string)))

	// required
	enabled := d.Get("enabled")
	export.SetEnabled(enabled.(bool))

	// required
	name := d.Get("name")
	export.SetName(name.(string))

	// optional
	if description, ok := d.GetOk("description"); ok {
		export.SetDescription(description.(string))
	}

	// optional
	if apiRoot, ok := d.GetOk("api_root"); ok {
		export.SetApiRoot(apiRoot.(string))
	}

	// optional
	if flowDest, ok := d.GetOk("flow_dest"); ok {
		export.SetFlowDest(flowDest.(string))
	}

	// required
	planID := d.Get("plan_id")
	export.SetPlanId(planID.(string))

	// required
	cloudProvider := d.Get("cloud_provider").(string) //nolint: errcheck, forcetypeassert // type enforced by schema
	export.SetCloudProvider(cloudProvider)

	// validation: for any given cloud_provider, there should also be an object of the same name,
	// containing configuration details, e.g. for cloud_provider="ibm", ibm{...} object should be defined
	providerObj, ok := d.GetOk(cloudProvider)
	if !ok {
		return nil, fmt.Errorf("for cloud_provider=%[1]s, there should also be %[1]s{...} attribute provided", cloudProvider)
	}
	providerDef := providerObj.([]interface{})[0]       // extract nested object under index 0. Terraform clumsiness
	providerMap := providerDef.(map[string]interface{}) //nolint: errcheck, forcetypeassert // type enforced by schema
	switch cloudProvider {
	case "aws":
		{
			aws := *cloudexport.NewV202101beta1AwsProperties()
			aws.SetBucket(providerMap["bucket"].(string))
			aws.SetIamRoleArn(providerMap["iam_role_arn"].(string))
			aws.SetRegion(providerMap["region"].(string))
			aws.SetDeleteAfterRead(providerMap["delete_after_read"].(bool))
			aws.SetMultipleBuckets(providerMap["multiple_buckets"].(bool))
			export.SetAws(aws)
		}
	case "azure":
		{
			azure := *cloudexport.NewV202101beta1AzureProperties()
			azure.SetLocation(providerMap["location"].(string))
			azure.SetResourceGroup(providerMap["resource_group"].(string))
			azure.SetStorageAccount(providerMap["storage_account"].(string))
			azure.SetSubscriptionId(providerMap["subscription_id"].(string))
			azure.SetSecurityPrincipalEnabled(providerMap["security_principal_enabled"].(bool))
			export.SetAzure(azure)
		}
	case "bgp":
		{
			bgp := *cloudexport.NewV202101beta1BgpProperties()
			bgp.SetApplyBgp(providerMap["apply_bgp"].(bool))
			bgp.SetUseBgpDeviceId(providerMap["use_bgp_device_id"].(string))
			bgp.SetDeviceBgpType(providerMap["device_bgp_type"].(string))
			export.SetBgp(bgp)
		}
	case "gce":
		{
			gce := *cloudexport.NewV202101beta1GceProperties()
			gce.SetProject(providerMap["project"].(string))
			gce.SetSubscription(providerMap["subscription"].(string))
			export.SetGce(gce)
		}
	case "ibm":
		{
			ibm := *cloudexport.NewV202101beta1IbmProperties()
			ibm.SetBucket(providerMap["bucket"].(string))
			export.SetIbm(ibm)
		}
	default:
		return nil, fmt.Errorf("cloud_provider should be one of [aws, azure, ibm, gce, bgp], got: %q", cloudProvider)
	}

	return export, nil
}
